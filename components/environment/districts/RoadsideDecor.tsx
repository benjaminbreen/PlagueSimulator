/**
 * Roadside Settlement Decorations
 * Similar to Southern Road but narrower road and less dense
 * Features rendered road surface, buildings, merchant stalls, outbuildings, clutter
 */

import React from 'react';
import { getDistrictType } from '../../../types';
import { seededRandom } from '../../../utils/procedural';

export const RoadsideDecor: React.FC<{ mapX: number; mapY: number }> = ({ mapX, mapY }) => {
  const district = getDistrictType(mapX, mapY);
  if (district !== 'ROADSIDE') return null;

  const seed = mapX * 73 + mapY * 137;
  const rand = (offset: number) => seededRandom(seed + offset);

  // Road configuration - narrower than Southern Road
  const roadWidth = 5.5;
  const ditchOffset = 6.0;
  const ditchWidth = 1.2;
  const length = 100;

  // Note: Main enterable buildings are now generated by the procedural building system in Environment.tsx
  // This component only handles decorative outbuildings, stalls, and clutter

  // Merchant stalls - 2-3 stalls
  const stallCount = 2 + (rand(100) > 0.6 ? 1 : 0);
  const stalls: Array<{ pos: [number, number, number]; rotation: number }> = [];
  for (let i = 0; i < stallCount; i++) {
    const side = rand(110 + i) > 0.5 ? -1 : 1;
    const zPos = -30 + (i * 30) + rand(120 + i) * 10;
    const xPos = side * (7 + rand(130 + i) * 2);
    stalls.push({
      pos: [xPos, 0, zPos],
      rotation: side > 0 ? -Math.PI / 2 : Math.PI / 2
    });
  }

  // Wells - 1-2 wells
  const wellCount = 1 + (rand(200) > 0.5 ? 1 : 0);
  const wells: Array<[number, number, number]> = [];
  for (let i = 0; i < wellCount; i++) {
    const side = i % 2 === 0 ? -1 : 1;
    const zPos = -25 + (i * 50) + rand(210 + i) * 15;
    const xPos = side * (12 + rand(220 + i) * 4);
    wells.push([xPos, 0, zPos]);
  }

  // Storage sheds - 3-5 outbuildings
  const shedCount = 3 + Math.floor(rand(300) * 3);
  const sheds: Array<{ pos: [number, number, number]; size: number; rotation: number }> = [];
  for (let i = 0; i < shedCount; i++) {
    const side = rand(310 + i) > 0.5 ? -1 : 1;
    const zPos = -35 + rand(320 + i) * 70;
    const xPos = side * (13 + rand(330 + i) * 5);
    sheds.push({
      pos: [xPos, 0, zPos],
      size: 1.5 + rand(340 + i) * 0.8,
      rotation: rand(350 + i) * Math.PI * 2
    });
  }

  // Crates and barrels - 8-12 scattered
  const crateCount = 8 + Math.floor(rand(400) * 5);
  const crates: Array<{ pos: [number, number, number]; size: number; isBarrel: boolean }> = [];
  for (let i = 0; i < crateCount; i++) {
    const side = rand(410 + i) > 0.5 ? -1 : 1;
    const zPos = -45 + rand(420 + i) * 90;
    const xPos = side * (8 + rand(430 + i) * 6);
    crates.push({
      pos: [xPos, 0, zPos],
      size: 0.4 + rand(440 + i) * 0.3,
      isBarrel: rand(450 + i) > 0.6
    });
  }

  // Animal pens - 2-3 pens
  const penCount = 2 + (rand(500) > 0.7 ? 1 : 0);
  const pens: Array<{ pos: [number, number, number]; rotation: number }> = [];
  for (let i = 0; i < penCount; i++) {
    const side = i % 2 === 0 ? -1 : 1;
    const zPos = -20 + (i * 35) + rand(510 + i) * 12;
    const xPos = side * (15 + rand(520 + i) * 3);
    pens.push({
      pos: [xPos, 0, zPos],
      rotation: rand(530 + i) * Math.PI * 2
    });
  }

  // Tethering posts - 4-6 posts for animals
  const postCount = 4 + Math.floor(rand(600) * 3);
  const posts: Array<[number, number, number]> = [];
  for (let i = 0; i < postCount; i++) {
    const side = rand(610 + i) > 0.5 ? -1 : 1;
    const zPos = -40 + rand(620 + i) * 80;
    const xPos = side * (9 + rand(630 + i) * 4);
    posts.push([xPos, 0, zPos]);
  }

  // Palm trees along roadside - 6-8 trees
  const treeCount = 6 + Math.floor(rand(700) * 3);
  const trees: Array<[number, number, number]> = [];
  for (let i = 0; i < treeCount; i++) {
    const side = i % 2 === 0 ? -1 : 1;
    const zPos = -45 + (i * 12) + rand(710 + i) * 8;
    const xPos = side * (16 + rand(720 + i) * 4);
    trees.push([xPos, 0, zPos]);
  }


  return (
    <group>
      {/* Main road surface - raised to avoid z-fighting */}
      <mesh position={[0, 0.08, 0]} receiveShadow>
        <boxGeometry args={[roadWidth, 0.1, length]} />
        <meshStandardMaterial color="#b08a5a" roughness={0.95} />
      </mesh>

      {/* Center worn path - clearly above main road surface */}
      <mesh position={[0, 0.14, 0]} receiveShadow>
        <boxGeometry args={[roadWidth * 0.55, 0.02, length]} />
        <meshStandardMaterial color="#a0794d" roughness={0.95} />
      </mesh>

      {/* Road edge detail - slight bevel */}
      <mesh position={[-roadWidth / 2 + 0.15, 0.06, 0]} receiveShadow>
        <boxGeometry args={[0.3, 0.06, length]} />
        <meshStandardMaterial color="#9a7a4d" roughness={0.95} />
      </mesh>
      <mesh position={[roadWidth / 2 - 0.15, 0.06, 0]} receiveShadow>
        <boxGeometry args={[0.3, 0.06, length]} />
        <meshStandardMaterial color="#9a7a4d" roughness={0.95} />
      </mesh>

      {/* Ditches on both sides */}
      <mesh position={[-ditchOffset, -0.12, 0]} receiveShadow>
        <boxGeometry args={[ditchWidth, 0.24, length]} />
        <meshStandardMaterial color="#8a6a43" roughness={0.98} />
      </mesh>
      <mesh position={[ditchOffset, -0.12, 0]} receiveShadow>
        <boxGeometry args={[ditchWidth, 0.24, length]} />
        <meshStandardMaterial color="#8a6a43" roughness={0.98} />
      </mesh>


      {/* Merchant stalls */}
      {stalls.map((stall, i) => (
        <group key={`stall-${i}`} position={stall.pos} rotation={[0, stall.rotation, 0]}>
          {/* Posts */}
          <mesh position={[-1.2, 1.2, 0]} castShadow>
            <cylinderGeometry args={[0.08, 0.08, 2.4, 8]} />
            <meshStandardMaterial color="#7a5a3a" roughness={0.92} />
          </mesh>
          <mesh position={[1.2, 1.2, 0]} castShadow>
            <cylinderGeometry args={[0.08, 0.08, 2.4, 8]} />
            <meshStandardMaterial color="#7a5a3a" roughness={0.92} />
          </mesh>

          {/* Canvas awning */}
          <mesh position={[0, 2.3, 0.3]} rotation={[Math.PI * 0.15, 0, 0]} castShadow>
            <boxGeometry args={[2.6, 0.02, 1.8]} />
            <meshStandardMaterial color="#d4a574" roughness={0.82} />
          </mesh>

          {/* Counter */}
          <mesh position={[0, 0.9, 0]} castShadow receiveShadow>
            <boxGeometry args={[2.4, 0.1, 0.8]} />
            <meshStandardMaterial color="#8a6a4a" roughness={0.92} />
          </mesh>

          {/* Goods on display */}
          <mesh position={[-0.7, 0.35, 0]} castShadow>
            <boxGeometry args={[0.5, 0.5, 0.4]} />
            <meshStandardMaterial color="#9a7a5a" roughness={0.95} />
          </mesh>
          <mesh position={[0.7, 0.35, 0]} castShadow>
            <boxGeometry args={[0.4, 0.5, 0.5]} />
            <meshStandardMaterial color="#8a6a4a" roughness={0.95} />
          </mesh>
          <mesh position={[0, 0.25, 0.3]} castShadow>
            <boxGeometry args={[0.6, 0.4, 0.4]} />
            <meshStandardMaterial color="#b88a5a" roughness={0.95} />
          </mesh>
        </group>
      ))}

      {/* Wells */}
      {wells.map((wellPos, i) => (
        <group key={`well-${i}`} position={wellPos}>
          {/* Well rim */}
          <mesh position={[0, 0.4, 0]} castShadow receiveShadow>
            <cylinderGeometry args={[1.0, 1.1, 0.8, 12]} />
            <meshStandardMaterial color="#8a8a7a" roughness={0.94} />
          </mesh>

          {/* Well interior */}
          <mesh position={[0, 0.4, 0]}>
            <cylinderGeometry args={[0.8, 0.8, 0.9, 12]} />
            <meshStandardMaterial color="#1a1a1a" roughness={0.7} />
          </mesh>

          {/* Wooden beam */}
          <mesh position={[0, 1.4, 0]} rotation={[0, 0, Math.PI / 2]} castShadow>
            <cylinderGeometry args={[0.08, 0.08, 1.8, 8]} />
            <meshStandardMaterial color="#5a4a3a" roughness={0.94} />
          </mesh>

          {/* Support posts */}
          <mesh position={[-0.8, 0.7, 0]} castShadow>
            <cylinderGeometry args={[0.08, 0.1, 1.4, 6]} />
            <meshStandardMaterial color="#6a5a4a" roughness={0.94} />
          </mesh>
          <mesh position={[0.8, 0.7, 0]} castShadow>
            <cylinderGeometry args={[0.08, 0.1, 1.4, 6]} />
            <meshStandardMaterial color="#6a5a4a" roughness={0.94} />
          </mesh>

          {/* Bucket */}
          <mesh position={[0.3, 0.5, 0]} castShadow>
            <cylinderGeometry args={[0.15, 0.18, 0.35, 8]} />
            <meshStandardMaterial color="#7a6a5a" roughness={0.9} />
          </mesh>
        </group>
      ))}

      {/* Storage sheds */}
      {sheds.map((shed, i) => (
        <group key={`shed-${i}`} position={shed.pos} rotation={[0, shed.rotation, 0]}>
          <mesh position={[0, shed.size * 0.5, 0]} castShadow receiveShadow>
            <boxGeometry args={[shed.size * 1.5, shed.size, shed.size * 1.2]} />
            <meshStandardMaterial color="#8a7a6a" roughness={0.96} />
          </mesh>
          {/* Slanted roof */}
          <mesh position={[0, shed.size * 1.1, 0]} rotation={[0, 0, 0]} castShadow>
            <boxGeometry args={[shed.size * 1.6, 0.1, shed.size * 1.3]} />
            <meshStandardMaterial color="#7a6a5a" roughness={0.97} />
          </mesh>
        </group>
      ))}

      {/* Crates and barrels */}
      {crates.map((crate, i) =>
        crate.isBarrel ? (
          <mesh key={`crate-${i}`} position={crate.pos} castShadow>
            <cylinderGeometry args={[crate.size, crate.size * 0.9, crate.size * 1.5, 8]} />
            <meshStandardMaterial color="#8a6a4a" roughness={0.94} />
          </mesh>
        ) : (
          <mesh key={`crate-${i}`} position={crate.pos} castShadow>
            <boxGeometry args={[crate.size, crate.size, crate.size]} />
            <meshStandardMaterial color="#9a7a5a" roughness={0.95} />
          </mesh>
        )
      )}

      {/* Animal pens */}
      {pens.map((pen, i) => (
        <group key={`pen-${i}`} position={pen.pos} rotation={[0, pen.rotation, 0]}>
          {/* Fence posts forming square */}
          {[0, 1, 2, 3].map((side) => {
            const angle = (side / 4) * Math.PI * 2;
            const radius = 2.0;
            return (
              <mesh
                key={`fence-${side}`}
                position={[Math.cos(angle) * radius, 0.6, Math.sin(angle) * radius]}
                rotation={[0, angle + Math.PI / 2, 0]}
                castShadow
              >
                <boxGeometry args={[0.1, 1.2, 3.5]} />
                <meshStandardMaterial color="#6a5a4a" roughness={0.94} />
              </mesh>
            );
          })}
          {/* Trough */}
          <mesh position={[0, 0.3, 0]} castShadow receiveShadow>
            <boxGeometry args={[1.2, 0.4, 0.4]} />
            <meshStandardMaterial color="#7a6a5a" roughness={0.92} />
          </mesh>
        </group>
      ))}

      {/* Tethering posts */}
      {posts.map((postPos, i) => (
        <group key={`post-${i}`} position={postPos}>
          <mesh position={[0, 0.8, 0]} castShadow>
            <cylinderGeometry args={[0.12, 0.15, 1.6, 8]} />
            <meshStandardMaterial color="#6a5a4a" roughness={0.93} />
          </mesh>
          {/* Ring at top */}
          <mesh position={[0, 1.5, 0]} rotation={[Math.PI / 2, 0, 0]} castShadow>
            <torusGeometry args={[0.15, 0.04, 8, 12]} />
            <meshStandardMaterial color="#4a3a2a" roughness={0.85} metalness={0.2} />
          </mesh>
        </group>
      ))}

      {/* Palm trees along roadside - REALISTIC DATE PALMS */}
      {trees.map((treePos, i) => {
        // Randomize each palm based on position
        const palmSeed = Math.abs(treePos[0] * 11 + treePos[2] * 17 + i * 29);
        const heightMult = 0.9 + (palmSeed % 25) / 100; // 0.9-1.15x height
        const trunkThickness = 0.2 + ((palmSeed % 12) / 150); // Vary trunk
        const frondCount = 6 + (palmSeed % 3); // 6-8 fronds

        return (
          <group key={`tree-${i}`} position={treePos}>
            {/* DATE PALM TRUNK - segmented realistic structure */}
            {/* Base segment */}
            <mesh position={[0, 0.5 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.08, trunkThickness + 0.12, 1.0 * heightMult, 10]} />
              <meshStandardMaterial color="#8a6a4a" roughness={0.94} />
            </mesh>
            {/* Segment ring */}
            <mesh position={[0, 0.95 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.09, trunkThickness + 0.09, 0.1, 10]} />
              <meshStandardMaterial color="#6a5a3a" roughness={0.97} />
            </mesh>
            {/* Mid-lower segment */}
            <mesh position={[0, 1.5 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.06, trunkThickness + 0.08, 1.0 * heightMult, 10]} />
              <meshStandardMaterial color="#7a5a3a" roughness={0.94} />
            </mesh>
            {/* Segment ring */}
            <mesh position={[0, 1.95 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.07, trunkThickness + 0.07, 0.1, 10]} />
              <meshStandardMaterial color="#6a5a3a" roughness={0.97} />
            </mesh>
            {/* Mid-upper segment */}
            <mesh position={[0, 2.6 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.04, trunkThickness + 0.06, 1.2 * heightMult, 10]} />
              <meshStandardMaterial color="#8a6a4a" roughness={0.94} />
            </mesh>
            {/* Segment ring */}
            <mesh position={[0, 3.15 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.05, trunkThickness + 0.05, 0.1, 10]} />
              <meshStandardMaterial color="#6a5a3a" roughness={0.97} />
            </mesh>
            {/* Top segment */}
            <mesh position={[0, 3.6 * heightMult, 0]} castShadow>
              <cylinderGeometry args={[trunkThickness + 0.02, trunkThickness + 0.04, 0.9 * heightMult, 10]} />
              <meshStandardMaterial color="#7a5a3a" roughness={0.94} />
            </mesh>

            {/* Crown base where fronds emerge */}
            <mesh position={[0, 4.1 * heightMult, 0]} castShadow>
              <sphereGeometry args={[trunkThickness + 0.15, 8, 6]} />
              <meshStandardMaterial color="#5a6a3a" roughness={0.9} />
            </mesh>

            {/* REALISTIC PALM FRONDS - radiating outward */}
            {Array.from({ length: frondCount }).map((_, frondIdx) => {
              const angle = (frondIdx / frondCount) * Math.PI * 2 + (palmSeed % 100) / 100;
              const droop = 0.6 + ((palmSeed + frondIdx) % 20) / 100; // Varied droop

              return (
                <group key={`frond-${frondIdx}`} position={[0, 4.15 * heightMult, 0]} rotation={[0, angle, 0]}>
                  {/* Frond stem (rachis) */}
                  <mesh position={[0, 0, 0.6]} rotation={[droop, 0, 0]} castShadow>
                    <cylinderGeometry args={[0.025, 0.035, 1.2, 6]} />
                    <meshStandardMaterial color="#6a7a4a" roughness={0.92} />
                  </mesh>

                  {/* Leaflets along frond - alternating sides */}
                  {Array.from({ length: 10 }).map((_, leafIdx) => {
                    const leafOffset = (leafIdx / 9) * 1.1;
                    const leafSide = leafIdx % 2 === 0 ? 0.4 : -0.4;
                    const leafSize = 0.3 - leafIdx * 0.02; // Smaller toward tip

                    return (
                      <group
                        key={`leaf-${leafIdx}`}
                        position={[0, Math.sin(droop) * leafOffset * 0.3, leafOffset]}
                        rotation={[droop + leafIdx * 0.04, 0, leafSide]}
                      >
                        <mesh castShadow>
                          <boxGeometry args={[leafSize, 0.01, 0.15]} />
                          <meshStandardMaterial
                            color={leafIdx < 3 ? '#5a7a3a' : leafIdx < 7 ? '#4a6a2a' : '#3a5a2a'}
                            roughness={0.87}
                            side={2}
                          />
                        </mesh>
                      </group>
                    );
                  })}
                </group>
              );
            })}

            {/* Date clusters hanging from crown */}
            {[0, 1, 2].map((clusterIdx) => {
              const clusterAngle = (clusterIdx / 3) * Math.PI * 2 + palmSeed;
              const clusterX = Math.cos(clusterAngle) * 0.15;
              const clusterZ = Math.sin(clusterAngle) * 0.15;

              return (
                <group key={`dates-${clusterIdx}`} position={[clusterX, 3.8 * heightMult, clusterZ]}>
                  {[0, 1, 2, 3, 4].map((dateIdx) => (
                    <mesh
                      key={`date-${dateIdx}`}
                      position={[
                        (Math.sin(palmSeed + dateIdx) - 0.5) * 0.08,
                        -dateIdx * 0.06,
                        (Math.cos(palmSeed + dateIdx) - 0.5) * 0.08
                      ]}
                      castShadow
                    >
                      <sphereGeometry args={[0.03, 6, 4]} />
                      <meshStandardMaterial color="#6a4a2a" roughness={0.8} />
                    </mesh>
                  ))}
                </group>
              );
            })}
          </group>
        );
      })}

    </group>
  );
};
